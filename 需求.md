这个文件你不需要修改，每次有新功能/修改优化需求我会写在这里，完成以后我会删除

1. 现在最大的两个“致命点”
   （1）config-version 会一直更新失败

现在这段逻辑里，所有 key 都统一用用户配置覆盖默认配置：

val userValue = if (userConfig.contains(fullKey)) {
userConfig.get(fullKey)
} else null


如果默认 config.yml 里已经改成：

config-version: 12


但用户旧配置里是：

config-version: 9


那你在合并时会把默认的 12 覆盖回 9。
写回磁盘后，插件再读 config 时还是 9，下次启动又觉得版本不对，再更新一次，进入无限更新循环。

👉 建议：在 processConfigLine 里对 config-version 特判，不允许用用户的值覆盖，直接写死当前版本：

if (fullKey == "config-version") {
// 强制写当前版本
val commentPart = if (comment.isNotEmpty()) "  $comment" else ""
return "$indent$key: $CURRENT_CONFIG_VERSION$commentPart"
}


这样每次更新完，config 里一定是最新版本号。

（2）List 类型的配置基本没被正确合并

你现在的逻辑是按“单行 key: value”处理的：

像 foo: bar 这种，能正常走到 formatValue

但 YAML 里很常见这种：

allowed-worlds:
- world
- world_nether


对 allowed-worlds: 这一行来说：

afterColon 是空字符串

所以 valuePartWithoutComment 为空

你把它当成“节点标题”，直接 return line，不会用用户的 List 覆盖

更重要的是：下面 - world、- world_nether 这几行不含冒号，你的代码也不会处理，只是原样保留默认配置。
👇 结果就是：用户改过的列表完全无效，最后仍然是默认值。

这个如果你有用到 string-list 或 world-list 之类配置，很容易出事故。

建议两种方案二选一：

简单模式（够用版）
直接放弃对 List 的“精确保留注释”，只要检测到用户有这个 key 的 List，就整块用 Bukkit 自己序列化出来的覆盖：

if (valuePartWithoutComment.isEmpty()) {
// 尝试看看是不是 list
val list = userConfig.getList(fullKey)
if (list != null) {
// 我们自己重新输出这一段，顺便跳过后面默认的 list 行
return buildListBlock(indent, key, list, comment)
}

    keyStack.add(key to indentLevel)
    return line
}


然后在主循环里多加一段逻辑：当我们决定“自己重写 list 块”时，向下跳过原默认 list 的 - xxx 行。

暴力稳定模式（推荐一点）
不自己组 YAML，用 Bukkit 的 YamlConfiguration 来帮你格式化值（后面第 3 点我会细讲）。

2. 字符串 & 注释这一块的坑
   （1）行尾 # 会被误判成注释

你现在用的是：

val commentMatch = """#.*$""".toRegex().find(afterColon)


如果用户写的是：

prefix: "&7[#]&r "
color: "#ffffff"


这种情况：

"#ffffff" 里本来就是合法字符串，# 不应该当注释

但你的 regex 会把 #ffffff" 当注释

结果 valuePartWithoutComment 变成空，整行逻辑就错了

要完全正确区分“# 在引号里”和“真的注释”其实很麻烦，基本就是在写一个不完整的 YAML 解析器。
现实一点的做法是：尽量依赖 YamlConfiguration 自己的保存逻辑（后面会讲一个稳定方案）。

（2）字符串加引号但不转义 "

formatValue 里，你有：

if (value.contains("&") || value.contains("#") || value.contains(":") ||
value.contains("[") || value.contains("]") || value.contains("\"")) {
"\"$value\""
}


如果 value 本身就是 He said "hi"，写出来就变成：

message: "He said "hi""


这就是非法 YAML，服务器下次启动会直接读挂。

同样地，要自己处理所有转义（换行、反斜杠、双引号……）真的很折腾，不如直接交给 Bukkit / SnakeYAML 来处理。

3. 建议：把“怎么写值”这块全部交给 YamlConfiguration

你已经在读的时候用 YamlConfiguration 了，其实可以再走一步：

写值的时候也借助它来生成“合法的 YAML 字符串片段”。

比如，把 formatValue 改成这样思路：

private fun formatValue(value: Any?): String {
val temp = YamlConfiguration()
temp.set("v", value)
val raw = temp.saveToString()   // 会生成：
// v: xxx\n
return raw
.lineSequence()
.first { it.startsWith("v:") }
.substringAfter("v: ")
}


这样：

字符串里有双引号、#、:、换行、反斜杠都由 SnakeYAML 负责

List / 数字 / 布尔值 / Map 都是合法的 YAML

你只负责拼接 key、缩进和注释就好了

如果你懒一点，还可以在处理整行时直接用它来生成整行，然后再拼上注释。

4. 其它小细节（可以慢慢优化）
   （1）extractAllValues 基本没用到

你现在：

val userValues = mutableMapOf<String, Any?>()
extractAllValues(currentConfig, "", userValues)
val updatedConfigText = mergeConfigWithComments(defaultConfigText, userValues, currentConfig)


但在 mergeConfigWithComments 里，真正用的是 userConfig，userValues 完全没参与逻辑。

👉 要么删掉 extractAllValues，要么改成真的用 userValues 来提高一点性能（比如不用每次做 contains/get）。

（2）默认配置的编码
val defaultConfigText = plugin.getResource("config.yml")?.let {
InputStreamReader(it).readText()
}


建议加 UTF-8：

val defaultConfigText = plugin.getResource("config.yml")?.use {
InputStreamReader(it, Charsets.UTF_8).readText()
}


use {} 会自动关流

指定 UTF-8，避免某些奇怪环境下中文注释变乱码

（3）备份文件可以带版本号

现在你固定备份到：config.yml.backup，如果你之后连着改了几版，很难知道这个备份是几代之前的。

可以考虑：

val backupFile = File(plugin.dataFolder, "config-v$currentVersion.yml.bak")


顺便在日志里打：

plugin.logger.info("已备份旧配置文件到: ${backupFile.name}")


看起来就很清晰。

（4）是否要在更新后 reloadConfig()

checkAndUpdate() 现在只是把文件写回磁盘，如果你后面马上要用 plugin.config 里的值，最好在外面调用完之后：

if (configUpdateManager.checkAndUpdate()) {
plugin.reloadConfig()
}


不然内存中的 plugin.config 还是旧内容。

5. 总结一下给你的结论

如果简短讲：

✅ 整体架构没问题：有版本号、有备份、有注释保留思想，很棒

⚠️ 必须改的两个点：

config-version 不能被用户旧值覆盖

List（尤其是 key:\n - a\n - b 这种）现在几乎没按用户配置生效

🔧 强烈建议把“值如何序列化为 YAML”交给 YamlConfiguration.saveToString()，自己专心搞格式 & 注释逻辑，会稳很多